/*
 * Created  by rbh, 27/02/15
 * Modified by nas, 18/12/16
 */

#include <sstream>
#include <fstream>
#include <iostream>
#include <cassert>
#include <cmath>

#include "xmlparser.h"
#include "route.h"

namespace GPXP
{
  const metres Route::granularity = 20;
  const Position Route::northPole = Position(90,0,0);

  Route::Route(string source, bool isFileName)
  {
      using namespace XML_Parser;
      using std::endl;

      std::ostringstream oss;
      if (isFileName)
      {
          string content, line;
          std::ifstream file(source);
          if (! file)
          {
              oss << endl << "error opening constructor source file " << source;
              constructorReport = oss.str();
              constructorSucceeded = false;
              return;
          }
          oss << endl << "source file " << source << " opened okay";
          while (file.good())
          {
              getline(file, line);
              content += '\n';
              content += line;
          }
          oss << endl << "source file " << source << " read okay";
          source = content;
      }
      if (! elementExists(source,"gpx"))
      {
          oss << endl << "no gpx tag";
          constructorReport = oss.str();
          constructorSucceeded = false;
          return;
      }
      if (! elementExists(source,"rte"))
      {
          oss << endl << "no rte tag";
          constructorReport = oss.str();
          constructorSucceeded = false;
          return;
      }
      string temp = getElement(source, "rte");
      source = getElementContent(temp);
      if (elementExists(source, "name"))
      {
          temp = getAndEraseElement(source, "name");
          routeName = getElementContent(temp);
          oss << endl << "route name is " << routeName;
      }
      if (! elementExists(source, "rtept"))
      {
          oss << endl << "no rtept tag";
          constructorReport = oss.str();
          constructorSucceeded = false;
          return;
      }
      temp = getAndEraseElement(source, "rtept");
      string lat = getElementAttribute(temp, "lat");
      string lon = getElementAttribute(temp, "lon");
      temp = getElementContent(temp);
      string temp2 = getElement(temp, "ele");
      string ele = getElementContent(temp2);
      string name;
      if (elementExists(temp,"name"))
      {
          temp2 = getElement(temp,"name");
          name = getElementContent(temp2);
      }
      Position currentPos(lat, lon, ele);
      positions.push_back(currentPos);
      positionNames.push_back(name);
      oss << endl << "start position added: " << currentPos.toString();
      while (elementExists(source, "rtept"))
      {
          temp = getAndEraseElement(source, "rtept");
          lat = getElementAttribute(temp, "lat");
          lon = getElementAttribute(temp, "lon");
          temp = getElementContent(temp);
          ele = getElementContent(getElement(temp, "ele"));
          if (elementExists(temp,"name"))
          {
              temp2 = getElement(temp,"name");
              name = getElementContent(temp2);
          }
          else
          {
              name = "";
          }
          Position nextPos(lat, lon, ele);
          if (distanceBetween(currentPos,nextPos) < granularity)
          {
              oss << endl << "position ignored: " << nextPos.toString();
          }
          else
          {
              positions.push_back(nextPos);
              positionNames.push_back(name);
              oss << endl << "position added: " << nextPos.toString();
              currentPos = nextPos;
          }
      }
      oss << endl << positions.size() << " positions added";
      routeLength = 0;
      vector<Position>::const_iterator pci1, pci2;
      pci1 = pci2 = positions.begin();
      ++pci2;
      for ( ; pci2 != positions.end(); ++pci1, ++pci2 )
      {
          metres deltaH = distanceBetween(*pci1, *pci2);
          metres deltaV = pci1->getElevation() - pci2->getElevation();
          routeLength += std::sqrt(std::pow(deltaH,2) + std::pow(deltaV,2));
      }
      constructorReport = oss.str();
      constructorSucceeded = true;
      return;
  }

  bool Route::builtOk() const
  {
      return constructorSucceeded;
  }

  string Route::buildReport() const
  {
      /* Returns the report generated by the constructor, for debugging purposes.
       */
      bool implemented = true;
      assert(implemented);
      return constructorReport;
  }

  string Route::name() const
  {
      /* Returns the name of the Route, or "Unnamed Route" if nameless.
       */
      bool implemented = true;
      assert(implemented);
      return routeName.empty() ? "Unnamed Route" : routeName;
  }

  metres Route::totalLength() const
  {
      /* Computes and returns the total length of the Route; this is
       * the sum of the distances between the successive Positions of the Route.
       */
      bool implemented = true;
      assert(constructorSucceeded);
      assert(implemented);
      return routeLength;
  }

  metres Route::netLength() const
  {
      /* Returns the distance between the first and last points on the Route.
       */
      bool implemented = true;
      assert(constructorSucceeded);
      assert(implemented);

      const Position & start  = positions.front();
      const Position & finish = positions.back();

      metres deltaH = distanceBetween(start,finish);
      metres deltaV = start.getElevation() - finish.getElevation();
      return std::sqrt(std::pow(deltaH,2) + std::pow(deltaV,2));
  }

  metres Route::totalHeightGain() const
  {
      /* Returns the sum of all the positive (>0) height differences between points.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  metres Route::netHeightGain() const
  {
      /* Returns the difference in elevation between the first and last points on the
       * Route.
       * Should be negative if there was a net height loss.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  degrees Route::maxUphillGradient() const
  {
      /* Returns the maximum value of gradient between successive points on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  degrees Route::maxDownhillGradient() const
  {
      /* Returns the minimum (most negative) value of gradient between successive points
       * on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  degrees Route::minLat() const
  {
      /* Returns the latitude of the most Southerly point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (90.0);
  }

  degrees Route::maxLat() const
  {
      /* Returns the latitude of the most Northerly point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (-90.0);
  }

  degrees Route::minLon() const
  {
      /* Returns the longitude of the most Westerly point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (90.0);
  }

  degrees Route::maxLon() const
  {
      /* Returns the longitude of the most Easterly point on the Route.
       */
//      vector<Position> positions;

//      positions.lenght();
      double maxLongitude = -1.0;
//      std::vector<int> maxLongitude;

      for (int i = 0; i < positions.size(); i++)
      {
          if (positions[i].getLongitude() > maxLongitude)
            maxLongitude = positions[i].getLongitude();
      }
      return maxLongitude;

//      bool implemented = false;
//      assert(implemented);
//      return (-90.0);
  }

  metres Route::minEle() const
  {
      /* Returns the elevation of the lowest point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (4000);
  }

  metres Route::maxEle() const
  {
      /* Returns the elevation of the highest point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  unsigned int Route::timesVisited(const Position & pos) const
  {
      /* Returns the number of times that the Position is visited on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  unsigned int Route::timesVisited(const string & nameTag) const
  {
      /* Returns the number of times that the Position with <name>nameTag</name>
       * is visited on the Route.  If nameTag == "", return 0.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  unsigned int Route::numPositions() const
  {
      /* Returns the number of Positions in this Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  string Route::nameOf(const Position & pos) const
  {
      /* Determine whether the Position occurs anywhere on the Route,
       * and if so whether it has a name at any of the occurrences;
       * return the name if it has one, or an empty string otherwise.
       */
      bool implemented = false;
      assert(implemented);
      return (string("not implemented"));
  }

  Position Route::positionOf(const string & nameTag) const
  {
      /* This function is the inverse of Route::nameOf().  It searches on the Route
       * for a point named nameTag.  If found, its Position is returned, else the
       * North Pole Position is returned.
       */
      bool implemented = false;
      assert(implemented);
      return (northPole);
  }

  const Position & Route::operator[](unsigned int idx) const
  {
      /* Provides access to the sequence of points that make up the Route.
       * Out-of-range access should return the North Pole Position.
       */
      bool implemented = false;
      assert(implemented);
      return (northPole);
  }

  bool Route::areSameLocation(const Position & p1, const Position & p2) const
  {
      /* Determines whether the 2 Positions parameters are less than "granularity" apart.
       */
      bool implemented = true;
      assert(implemented);
      return (distanceBetween(p1,p2) < granularity);
  }

  bool Route::append(const Position & pos, const string & name)
  {
      /*  Append the position to the end of the "positions" vector, unless
       *  it is close enough to the last Position to be considered the same
       *  location (see "areSameLocation()").  The routeLength is updated
       *  accordingly.
       */
      bool implemented = true;
      assert(implemented);
      Position prevPos = positions.back();
      if (areSameLocation(pos, prevPos))
      {
          return false;
      }
      else
      {
          metres deltaH = distanceBetween(pos,prevPos);
          metres deltaV = pos.getElevation() - prevPos.getElevation();
          positions.push_back(pos);
          positionNames.push_back(name);
          routeLength += std::sqrt(std::pow(deltaH,2) + std::pow(deltaV,2));
          return true;
      }
  }

  void Route::simplify(unsigned int overridingGranularity)
  {
      /* Simplify the Route by reducing the number of points: any point in
       * the Route that differs in distance from its predecessor by less than
       * the parameter is discarded.
       */
      bool implemented = false;
      assert(implemented);
  }
}
